<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Gizmo PVP</title>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <link rel="stylesheet" href="styles/main.css">
  <link rel="stylesheet" href="styles/pvp-game.css">
</head>
<body>
<div id="pvp-container">
  <div class="header">
    <h2>üéÆ PVP –†—É–ª–µ—Ç–∫–∞</h2>
  </div>
  
  <div id="roulette-container">
    <div id="roulette-arrow"></div>
    <div id="roulette-track">
      <div id="roulette-slots-wrapper">
        <div id="roulette-slots"></div>
      </div>
    </div>
    <div id="winner-display"></div>
    <div id="bet-controls">
      <button id="place-bet-btn" class="bet-btn">–°–¥–µ–ª–∞—Ç—å —Å—Ç–∞–≤–∫—É</button>
      <div id="timer-display" style="display: none;">–û—Å—Ç–∞–ª–æ—Å—å: <span id="time-left">30</span>—Å</div>
    </div>
  </div>
  
  <div id="version">Build 3.2v (Stable)</div>
</div>

<div id="panel">
  <div class="tab-buttons">
    <button class="tab-button" onclick="window.location.href='index.html'">–ü—Ä–æ—Ñ–∏–ª—å</button>
    <button class="tab-button" onclick="window.location.href='index.html#shop'">–ú–∞–≥–∞–∑–∏–Ω</button>
    <button class="tab-button active" onclick="window.location.href='pvp-game.html'">PVP</button>
  </div>
</div>

<script>
const firebaseConfig = {
  apiKey: "AIzaSyC6EklCDD25kU_nuXyeh5mj9F24KECyYpM",
  databaseURL: "https://gizmo-27843-default-rtdb.firebaseio.com",
  projectId: "gizmo-27843"
};

let app;
try {
  app = firebase.getApp();
} catch (e) {
  app = firebase.initializeApp(firebaseConfig);
}
const db = firebase.database();

const currentPlayer = {
  id: window.Telegram?.WebApp?.initDataUnsafe?.user?.id || 'player_' + Math.random().toString(36).slice(2, 9),
  name: window.Telegram?.WebApp?.initDataUnsafe?.user?.first_name || '–ò–≥—Ä–æ–∫',
  lastActive: Date.now()
};

const gameState = {
  players: {},
  status: 'waiting',
  timer: 30,
  winner: null,
  colors: ['#FF5252', '#4CAF50', '#2196F3', '#FFC107', '#9C27B0', '#00BCD4'],
  usedColors: [],
  slotWidth: 0,
  serverTimeOffset: 0,
  lastUpdate: Date.now()
};

const rouletteSlots = document.getElementById('roulette-slots');
const rouletteSlotsWrapper = document.getElementById('roulette-slots-wrapper');
const winnerDisplay = document.getElementById('winner-display');
const placeBetBtn = document.getElementById('place-bet-btn');
const timerDisplay = document.getElementById('timer-display');
const timeLeftSpan = document.getElementById('time-left');

const gameRef = db.ref('pvpRoulette/game');
const playersRef = db.ref('pvpRoulette/players');
const serverTimeRef = db.ref('.info/serverTimeOffset');
function initRouletteGame() {
  serverTimeRef.on('value', (snap) => {
    gameState.serverTimeOffset = snap.val() || 0;
  });

  resetGame(true);
  
  document.addEventListener('visibilitychange', updatePlayerActivity);
  window.addEventListener('focus', updatePlayerActivity);
  setInterval(updatePlayerActivity, 10000);
  
  placeBetBtn.addEventListener('click', placeBet);
  
  gameRef.on('value', (snapshot) => {
    const game = snapshot.val();
    if (game) {
      updateGameState(game);
    }
  });
  
  playersRef.on('value', (snapshot) => {
    try {
      const players = snapshot.val() || {};
      updatePlayers(players);
      
      checkPlayersActivity(players);
      
      if (countActivePlayers(players) >= 2 && gameState.status === 'waiting') {
        startBettingTimer();
      }
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏–≥—Ä–æ–∫–æ–≤:', error);
    }
  }, (error) => {
    console.error('–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –∏–≥—Ä–æ–∫–æ–≤:', error);
  });
}

function updatePlayerActivity() {
  if (currentPlayer.id) {
    playersRef.child(currentPlayer.id).update({
      lastActive: Date.now()
    }).catch(error => {
      console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏:', error);
    });
  }
}

function checkPlayersActivity(players) {
  const now = Date.now();
  const inactiveTime = 30000;
  
  Object.entries(players).forEach(([playerId, player]) => {
    if (!player || now - (player.lastActive || 0) > inactiveTime) {
      playersRef.child(playerId).remove().catch(error => {
        console.error('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞:', error);
      });
    }
  });
}

function countActivePlayers(players) {
  const now = Date.now();
  const inactiveTime = 30000;
  
  return Object.values(players).filter(player => 
    player && now - (player.lastActive || 0) <= inactiveTime
  ).length;
}

function getServerTime() {
  return Date.now() + gameState.serverTimeOffset;
}

function resetGame(initial = false) {
  if (initial) {
    gameRef.set({
      status: 'waiting',
      startTime: null,
      winner: null,
      finishTime: null,
      lastReset: getServerTime()
    }).catch(error => {
      console.error('–û—à–∏–±–∫–∞ —Å–±—Ä–æ—Å–∞ –∏–≥—Ä—ã:', error);
    });
  }
  
  gameState.usedColors = [];
  gameState.winner = null;
  gameState.status = 'waiting';
  gameState.timer = 30;
  
  winnerDisplay.textContent = '';
  placeBetBtn.disabled = false;
  timerDisplay.style.display = 'none';
  
  rouletteSlots.innerHTML = '';
  rouletteSlotsWrapper.style.transition = 'none';
  rouletteSlotsWrapper.style.transform = 'translateX(0)';
}

function startBettingTimer() {
  if (gameState.status !== 'waiting') return;
  
  gameRef.update({
    status: 'betting',
    startTime: getServerTime()
  }).catch(error => {
    console.error('–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ —Ç–∞–π–º–µ—Ä–∞:', error);
  });
}

function placeBet() {
  if (gameState.status !== 'waiting' && gameState.status !== 'betting') {
    alert('–°—Ç–∞–≤–∫–∏ –≤—Ä–µ–º–µ–Ω–Ω–æ –∑–∞–∫—Ä—ã—Ç—ã');
    return;
  }
  
  if (gameState.players[currentPlayer.id]) {
    alert('–í—ã —É–∂–µ —Å–¥–µ–ª–∞–ª–∏ —Å—Ç–∞–≤–∫—É');
    return;
  }
  
  let availableColors = gameState.colors.filter(c => !gameState.usedColors.includes(c));
  if (availableColors.length === 0) {
    availableColors = gameState.colors;
    gameState.usedColors = [];
  }
  
  const randomColor = availableColors[Math.floor(Math.random() * availableColors.length)];
  gameState.usedColors.push(randomColor);
  
  const playerData = {
    name: currentPlayer.name,
    color: randomColor,
    betTime: getServerTime(),
    lastActive: Date.now()
  };
  
  playersRef.child(currentPlayer.id).set(playerData).catch(error => {
    console.error('–û—à–∏–±–∫–∞ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è —Å—Ç–∞–≤–∫–∏:', error);
    alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–∑–º–µ—â–µ–Ω–∏–∏ —Å—Ç–∞–≤–∫–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.');
  });
}

function updateGameState(game) {
  gameState.status = game.status;
  gameState.winner = game.winner || null;
  
  if (game.status === 'betting') {
    const elapsed = Math.floor((getServerTime() - game.startTime) / 1000);
    gameState.timer = Math.max(0, 30 - elapsed);
    timeLeftSpan.textContent = gameState.timer;
    
    if (gameState.timer <= 0 && countActivePlayers(gameState.players) >= 2) {
      startRoulette();
    } else {
      updateTimerDisplay();
    }
  } else if (game.status === 'spinning') {
    placeBetBtn.disabled = true;
    timerDisplay.style.display = 'none';
  } else if (game.status === 'finished') {
    showWinner(game.winner);
    setTimeout(() => {
      resetGame();
      playersRef.remove().catch(error => {
        console.error('–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ –∏–≥—Ä–æ–∫–æ–≤:', error);
      });
    }, 10000);
  }
}

function updatePlayers(players) {
  gameState.players = players;
  updateRouletteDisplay();
}

function updateRouletteDisplay() {
  rouletteSlots.innerHTML = '';
  const activePlayers = Object.values(gameState.players)
    .filter(player => player && Date.now() - (player.lastActive || 0) <= 30000);
  
  const totalPlayers = activePlayers.length;
  if (totalPlayers === 0) return;
  
  gameState.slotWidth = 100 / totalPlayers;
  
  activePlayers.forEach((player, index) => {
    if (player && player.color) {
      createSlot(player, index);
      if (index === 0) createSlot(player, -1);
    }
  });
}

function createSlot(player, index) {
  if (!player || !player.color) return;
  
  try {
    const slot = document.createElement('div');
    slot.className = 'roulette-slot';
    slot.style.backgroundColor = player.color;
    slot.style.width = `${gameState.slotWidth}%`;
    slot.style.left = `${index * gameState.slotWidth}%`;
    
    const percent = document.createElement('div');
    percent.className = 'slot-percent';
    percent.textContent = `${Math.round(100 / countActivePlayers(gameState.players))}%`;
    percent.style.color = getContrastColor(player.color);
    
    slot.appendChild(percent);
    rouletteSlots.appendChild(slot);
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å–ª–æ—Ç–∞:', error);
  }
}

function getContrastColor(hexColor) {
  if (!hexColor || typeof hexColor !== 'string' || hexColor.length < 7) return '#FFFFFF';
  
  try {
    const r = parseInt(hexColor.substring(1, 3), 16);
    const g = parseInt(hexColor.substring(3, 5), 16);
    const b = parseInt(hexColor.substring(5, 7), 16);
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    return brightness > 128 ? '#000000' : '#FFFFFF';
  } catch (e) {
    return '#FFFFFF';
  }
}

function updateTimerDisplay() {
  if (gameState.status === 'betting' && gameState.timer >= 0) {
    timerDisplay.style.display = 'block';
    timeLeftSpan.textContent = gameState.timer;
    
    if (gameState.timer > 0) {
      setTimeout(() => {
        const elapsed = Math.floor((getServerTime() - gameRef.startTime) / 1000);
        gameState.timer = Math.max(0, 30 - elapsed);
        updateTimerDisplay();
      }, 1000);
    }
  }
}

function startRoulette() {
  gameRef.update({
    status: 'spinning'
  }).then(() => {
    const activePlayers = Object.values(gameState.players)
      .filter(player => player && Date.now() - (player.lastActive || 0) <= 30000);
    
    if (activePlayers.length === 0) {
      resetGame();
      return;
    }
    
    const spinDuration = 3000 + Math.random() * 4000;
    const winnerIndex = Math.floor(Math.random() * activePlayers.length);
    const targetPosition = 100 - (winnerIndex * gameState.slotWidth);
    
    rouletteSlotsWrapper.style.transition = 'none';
    rouletteSlotsWrapper.style.transform = 'translateX(0)';
    
    setTimeout(() => {
      rouletteSlotsWrapper.style.transition = `transform ${spinDuration/1000}s cubic-bezier(0.2, 0.1, 0.2, 1)`;
      rouletteSlotsWrapper.style.transform = `translateX(-${targetPosition}%)`;
      
      setTimeout(() => {
        const winnerId = Object.keys(gameState.players)[winnerIndex];
        
        gameRef.update({
          status: 'finished',
          winner: winnerId,
          finishTime: getServerTime()
        }).catch(error => {
          console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ–±–µ–¥–∏—Ç–µ–ª—è:', error);
        });
      }, spinDuration);
    }, 10);
  }).catch(error => {
    console.error('–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ —Ä—É–ª–µ—Ç–∫–∏:', error);
  });
}

function showWinner(winnerId) {
  if (winnerId && gameState.players[winnerId]) {
    const winner = gameState.players[winnerId];
    winnerDisplay.innerHTML = `
      <div class="winner-box" style="background-color: ${winner.color || '#7f5af0'}">
        –ü–æ–±–µ–¥–∏—Ç–µ–ª—å: ${winner.name || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∏–≥—Ä–æ–∫'}!
      </div>
    `;
  }
}

document.addEventListener('DOMContentLoaded', initRouletteGame);
</script>
</body>
</html>