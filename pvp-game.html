<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Gizmo PVP</title>
  <link rel="stylesheet" href="styles/pvp-game.css">
  <link rel="stylesheet" href="styles/animation.css">
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
  <div id="pvp-container">
    <div class="header">
      <h1>PVP –†—É–ª–µ—Ç–∫–∞</h1>
    </div>
    
    <div id="roulette-container">
      <div id="roulette-arrow"></div>
      <div id="roulette-track">
        <div id="roulette-slots-wrapper">
          <div id="roulette-slots"></div>
        </div>
      </div>
      <div id="winner-display"></div>
      <div id="bet-controls">
        <button id="place-bet-btn" class="bet-btn">–°–¥–µ–ª–∞—Ç—å —Å—Ç–∞–≤–∫—É (10üí∞)</button>
        <div id="timer-display" style="display:none">–û—Å—Ç–∞–ª–æ—Å—å: <span id="time-left">30</span>—Å</div>
      </div>
    </div>
  </div>

  <!-- –ú–µ–Ω—é -->
  <div id="main-menu">
    <div class="menu-buttons">
      <button class="menu-btn" onclick="window.location.href='index.html'">
        <span class="btn-icon">üë§</span>
        <span class="btn-text">–ü—Ä–æ—Ñ–∏–ª—å</span>
      </button>
      <button class="menu-btn" onclick="window.location.href='index.html#shop'">
        <span class="btn-icon">üõí</span>
        <span class="btn-text">–ú–∞–≥–∞–∑–∏–Ω</span>
      </button>
      <button class="menu-btn" disabled>
        <span class="btn-icon">‚öîÔ∏è</span>
        <span class="btn-text">PVP</span>
      </button>
    </div>
  </div>

  <script>
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Firebase
    const firebaseConfig = {
      apiKey: "AIzaSyC6EklCDD25kU_nuXyeh5mj9F24KECyYpM",
      databaseURL: "https://gizmo-27843-default-rtdb.firebaseio.com"
    };
    
    const app = firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    // –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
    const gameState = {
      colors: ['#FF5252','#4CAF50','#2196F3','#FFC107','#9C27B0','#00BCD4'],
      slotWidth: 0,
      serverTimeOffset: 0,
      isPlacingBet: false,
      timerInterval: null,
      currentAnimation: null,
      currentRoom: null
    };

    // –≠–ª–µ–º–µ–Ω—Ç—ã –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
    const elements = {
      rouletteSlots: document.getElementById('roulette-slots'),
      rouletteSlotsWrapper: document.getElementById('roulette-slots-wrapper'),
      winnerDisplay: document.getElementById('winner-display'),
      placeBetBtn: document.getElementById('place-bet-btn'),
      timerDisplay: document.getElementById('timer-display'),
      timeLeftSpan: document.getElementById('time-left'),
      rouletteArrow: document.getElementById('roulette-arrow')
    };

    // –°—Å—ã–ª–∫–∏ Firebase
    const roomRef = db.ref('pvpRoulette/room');
    const serverTimeRef = db.ref('.info/serverTimeOffset');
    const presenceRef = currentPlayer ? db.ref(`userPresence/${currentPlayer.id}`) : null;

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä–æ–∫–∞
    function initPlayer() {
      if (currentPlayer && currentPlayer.id.startsWith('tg_')) {
        db.ref(`users/${currentPlayer.id}`).update({
          lastLogin: firebase.database.ServerValue.TIMESTAMP,
          isOnline: true
        });
      }
      initPresenceTracking();
    }

    // –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
    function initPresenceTracking() {
      if (!presenceRef) return;
      
      presenceRef.set(true);
      
      window.addEventListener('beforeunload', () => {
        presenceRef.set(false);
      });
      
      if (window.Telegram?.WebApp) {
        Telegram.WebApp.onEvent('viewportChanged', (e) => {
          presenceRef.set(e.isExpanded);
        });
      }
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã—Ö –∏–≥—Ä–æ–∫–æ–≤
    function checkInactivePlayers() {
      roomRef.child('players').once('value', snap => {
        const players = snap.val() || {};
        const now = Date.now();
        Object.entries(players).forEach(([id, player]) => {
          if (now - player.lastActive > 30000) {
            roomRef.child(`players/${id}`).remove();
          }
        });
      });
    }

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
    function initRouletteGame() {
      serverTimeRef.on('value', snap => {
        gameState.serverTimeOffset = snap.val() || 0;
      });
      
      roomRef.once('value').then(snap => {
        if (!snap.exists()) resetRoom();
      });
      
      elements.placeBetBtn.addEventListener('click', placeBetHandler);
      roomRef.on('value', roomListener);
      setInterval(checkInactivePlayers, 60000);
    }

    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∏–∑–º–µ–Ω–µ–Ω–∏–π –≤ –∫–æ–º–Ω–∞—Ç–µ
    function roomListener(snap) {
      const room = snap.val();
      if (!room) return resetRoom();
      
      gameState.currentRoom = room;
      const validPlayers = {};
      
      if (room.players) {
        Object.entries(room.players).forEach(([id, player]) => {
          if (player?.color && player?.name && player?.lastActive) {
            validPlayers[id] = player;
          }
        });
      }
      
      if (Object.keys(validPlayers).length !== Object.keys(room.players || {}).length) {
        return roomRef.child('players').set(validPlayers);
      }
      
      updateUI(room);
    }

    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å—Ç–∞–≤–∫–∏
    async function placeBetHandler() {
      if (gameState.isPlacingBet || !currentPlayer?.id) return;
      gameState.isPlacingBet = true;
      elements.placeBetBtn.disabled = true;
      elements.placeBetBtn.textContent = '–°—Ç–∞–≤–∫–∞ –ø—Ä–∏–Ω—è—Ç–∞';
      
      try {
        await roomRef.transaction(room => {
          if (!room) room = { status: 'waiting', players: {}, startTime: null, winner: null };
          if (room.status !== 'waiting' && room.status !== 'betting') throw new Error('–°—Ç–∞–≤–∫–∏ –∑–∞–∫—Ä—ã—Ç—ã');
          if (room.players?.[currentPlayer.id]) throw new Error('–í—ã —É–∂–µ —Å–¥–µ–ª–∞–ª–∏ —Å—Ç–∞–≤–∫—É');
          
          const usedColors = Object.values(room.players || {}).map(p => p.color).filter(Boolean);
          const availableColor = gameState.colors.find(c => !usedColors.includes(c)) || gameState.colors[0];
          
          room.players = room.players || {};
          room.players[currentPlayer.id] = {
            name: currentPlayer.name,
            username: currentPlayer.username,
            color: availableColor,
            lastActive: Date.now(),
            betAmount: 10
          };
          
          if (Object.keys(room.players).length >= 2 && room.status === 'waiting') {
            room.status = 'betting';
            room.startTime = Date.now() + gameState.serverTimeOffset;
          }
          
          return room;
        });
        
        if (currentPlayer.id.startsWith('tg_')) {
          await db.ref(`users/${currentPlayer.id}/balance`).transaction(balance => {
            return (balance || 100) - 10;
          });
        }
      } catch(err) {
        alert(err.message);
      } finally {
        gameState.isPlacingBet = false;
        updateButtonState();
      }
    }

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∫–Ω–æ–ø–∫–∏
    function updateButtonState() {
      roomRef.once('value').then(snap => {
        const room = snap.val();
        if (room?.players?.[currentPlayer.id]) {
          elements.placeBetBtn.disabled = true;
          elements.placeBetBtn.textContent = '–í—ã –≤ –∏–≥—Ä–µ';
        } else {
          elements.placeBetBtn.disabled = false;
          elements.placeBetBtn.textContent = '–°–¥–µ–ª–∞—Ç—å —Å—Ç–∞–≤–∫—É (10üí∞)';
        }
      });
    }

    // –°–±—Ä–æ—Å –∫–æ–º–Ω–∞—Ç—ã
    function resetRoom() {
      clearTimer();
      if (gameState.currentAnimation) {
        cancelAnimationFrame(gameState.currentAnimation);
        gameState.currentAnimation = null;
      }
      
      const roomData = {
        status: 'waiting',
        players: {},
        startTime: null,
        winner: null,
        lastReset: Date.now() + gameState.serverTimeOffset
      };
      
      return roomRef.set(roomData);
    }

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
    function updateUI(room) {
      clearTimer();
      
      switch(room.status) {
        case 'waiting':
          updateButtonState();
          elements.timerDisplay.style.display = 'none';
          elements.winnerDisplay.textContent = '';
          break;
          
        case 'betting':
          updateButtonState();
          if (room.startTime) startTimer(room.startTime);
          break;
          
        case 'spinning':
          elements.placeBetBtn.disabled = true;
          elements.timerDisplay.style.display = 'none';
          break;
          
        case 'finished':
          showWinner(room.winner);
          elements.placeBetBtn.disabled = true;
          elements.timerDisplay.style.display = 'none';
          break;
      }
      
      updateRouletteDisplay(room.players || {});
    }

    // –ó–∞–ø—É—Å–∫ —Ç–∞–π–º–µ—Ä–∞
    function startTimer(startTime) {
      clearTimer();
      elements.timerDisplay.style.display = 'block';
      
      function updateTimer() {
        const elapsed = Math.floor((Date.now() + gameState.serverTimeOffset - startTime) / 1000);
        const timeLeft = Math.max(0, 30 - elapsed);
        elements.timeLeftSpan.textContent = timeLeft;
        
        if (timeLeft <= 0) {
          clearTimer();
          checkStartRoulette();
        }
      }
      
      updateTimer();
      gameState.timerInterval = setInterval(updateTimer, 1000);
    }

    // –û—á–∏—Å—Ç–∫–∞ —Ç–∞–π–º–µ—Ä–∞
    function clearTimer() {
      if (gameState.timerInterval) {
        clearInterval(gameState.timerInterval);
        gameState.timerInterval = null;
      }
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ä—Ç–∞ —Ä—É–ª–µ—Ç–∫–∏
    function checkStartRoulette() {
      roomRef.once('value').then(snap => {
        const room = snap.val();
        if (room?.status === 'betting' && Object.keys(room.players || {}).length >= 2) {
          startRoulette(room);
        }
      });
    }

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ä—É–ª–µ—Ç–∫–∏
    function updateRouletteDisplay(players) {
      elements.rouletteSlots.innerHTML = '';
      const activePlayers = Object.values(players).filter(p => p?.color);
      const totalPlayers = activePlayers.length;
      if (totalPlayers === 0) return;
      
      gameState.slotWidth = 100 / totalPlayers;
      activePlayers.forEach((player, index) => {
        createSlot(player, index, totalPlayers);
        createSlot(player, index + totalPlayers, totalPlayers);
      });
    }

    // –°–æ–∑–¥–∞–Ω–∏–µ —Å–ª–æ—Ç–∞
    function createSlot(player, index, totalPlayers) {
      const slot = document.createElement('div');
      slot.className = 'roulette-slot';
      slot.style.backgroundColor = player.color;
      slot.style.width = `${gameState.slotWidth}%`;
      slot.style.left = `${index * gameState.slotWidth}%`;
      
      const percent = document.createElement('div');
      percent.className = 'slot-percent';
      percent.textContent = `${Math.round(100/totalPlayers)}%`;
      percent.style.color = getContrastColor(player.color);
      slot.appendChild(percent);
      
      elements.rouletteSlots.appendChild(slot);
    }

    // –ó–∞–ø—É—Å–∫ —Ä—É–ª–µ—Ç–∫–∏
    function startRoulette(room) {
      const activePlayers = Object.entries(room.players || {}).filter(([_,p]) => p?.color);
      if (activePlayers.length < 2) return resetRoom();
      
      roomRef.update({status:'spinning'}).then(() => {
        const spinDuration = 5000;
        const winnerIndex = Math.floor(Math.random() * activePlayers.length);
        const winnerId = activePlayers[winnerIndex][0];
        const winner = activePlayers[winnerIndex][1];
        gameState.slotWidth = 100 / activePlayers.length;
        
        animateRoulette(winnerIndex, spinDuration, () => {
          roomRef.update({
            status: 'finished',
            winner: { id: winnerId, name: winner.name, color: winner.color },
            finishTime: Date.now() + gameState.serverTimeOffset
          }).then(() => {
            if (winnerId === currentPlayer.id && currentPlayer.id.startsWith('tg_')) {
              db.ref(`users/${currentPlayer.id}/balance`).transaction(balance => {
                return (balance || 0) + 20;
              });
              db.ref(`users/${currentPlayer.id}/stats/wins`).transaction(wins => {
                return (wins || 0) + 1;
              });
            }
            setTimeout(resetRoom, 10000);
          });
        });
      });
    }

    // –ê–Ω–∏–º–∞—Ü–∏—è —Ä—É–ª–µ—Ç–∫–∏
    function animateRoulette(winnerIndex, duration, callback) {
      const startTime = Date.now();
      const totalSlots = Object.keys(gameState.currentRoom?.players || {}).length;
      const targetPosition = 100 - winnerIndex * gameState.slotWidth;
      const totalWidth = totalSlots * gameState.slotWidth * 2;
      
      elements.rouletteSlotsWrapper.style.transition = 'none';
      elements.rouletteSlotsWrapper.style.transform = 'translateX(0)';
      
      function animate() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed/duration, 1);
        const easingProgress = progress < 0.8 ? progress*1.25 : 0.8+easeInOutQuad((progress-0.8)/0.2)*0.2;
        const currentPosition = easingProgress * targetPosition;
        const wrappedPosition = currentPosition % totalWidth;
        
        elements.rouletteSlotsWrapper.style.transform = `translateX(-${wrappedPosition}%)`;
        
        if (progress < 1) {
          gameState.currentAnimation = requestAnimationFrame(animate);
        } else {
          gameState.currentAnimation = null;
          callback();
        }
      }
      
      function easeOutQuad(t) { return t*(2-t); }
      function easeInOutQuad(t) { return t<0.5 ? 2*t*t : -1+(4-2*t)*t; }
      
      gameState.currentAnimation = requestAnimationFrame(animate);
    }

    // –ü–æ–∫–∞–∑ –ø–æ–±–µ–¥–∏—Ç–µ–ª—è
    function showWinner(winner) {
      if (!winner) return;
      
      const isWinner = winner.id === currentPlayer.id;
      elements.winnerDisplay.innerHTML = `
        <div class="winner-box" style="background-color:${winner.color || '#7f5af0'}">
          ${isWinner ? 'üéâ –í—ã –ø–æ–±–µ–¥–∏–ª–∏! +20üí∞' : `–ü–æ–±–µ–¥–∏—Ç–µ–ª—å: ${winner.name || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∏–≥—Ä–æ–∫'}!`}
        </div>`;
    }

    // –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–Ω—Ç—Ä–∞—Å—Ç–Ω–æ–≥–æ —Ü–≤–µ—Ç–∞
    function getContrastColor(hex) {
      if (!hex || typeof hex !== 'string' || hex.length < 7) return '#FFFFFF';
      const r = parseInt(hex.substring(1,3),16);
      const g = parseInt(hex.substring(3,5),16);
      const b = parseInt(hex.substring(5,7),16);
      return (r*299 + g*587 + b*114)/1000 > 128 ? '#000000' : '#FFFFFF';
    }

    // –ü—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    document.addEventListener('DOMContentLoaded', () => {
      initPlayer();
      initRouletteGame();
    });
  </script>
</body>
</html>