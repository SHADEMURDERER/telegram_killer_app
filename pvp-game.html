<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Gizmo PVP</title>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <link rel="stylesheet" href="styles/main.css">
  <link rel="stylesheet" href="styles/pvp-game.css">
</head>
<body>
<div id="pvp-container">
  <div class="header">
    <h2>üéÆ PVP –†—É–ª–µ—Ç–∫–∞</h2>
  </div>
  
  <div id="roulette-container">
    <div id="roulette-arrow"></div>
    <div id="roulette-track">
      <div id="roulette-slots-wrapper">
        <div id="roulette-slots"></div>
      </div>
    </div>
    <div id="winner-display"></div>
    <div id="bet-controls">
      <button id="place-bet-btn" class="bet-btn">–°–¥–µ–ª–∞—Ç—å —Å—Ç–∞–≤–∫—É</button>
      <div id="timer-display" style="display:none;">–û—Å—Ç–∞–ª–æ—Å—å: <span id="time-left">30</span>—Å</div>
    </div>
  </div>
  
  <div id="version">Build 5.3v</div>
</div>

<div id="panel">
  <div class="tab-buttons">
    <button class="tab-button" onclick="window.location.href='index.html'">–ü—Ä–æ—Ñ–∏–ª—å</button>
    <button class="tab-button" onclick="window.location.href='index.html#shop'">–ú–∞–≥–∞–∑–∏–Ω</button>
    <button class="tab-button active" onclick="window.location.href='pvp-game.html'">PVP</button>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Firebase
  const firebaseConfig = {
    apiKey: "AIzaSyC6EklCDD25kU_nuXyeh5mj9F24KECyYpM",
    databaseURL: "https://gizmo-27843-default-rtdb.firebaseio.com",
    projectId: "gizmo-27843"
  };
  
  const app = firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  // –¢–µ–∫—É—â–∏–π –∏–≥—Ä–æ–∫
  const currentPlayer = {
    id: window.Telegram?.WebApp?.initDataUnsafe?.user?.id || 'player_'+Math.random().toString(36).slice(2,9),
    name: window.Telegram?.WebApp?.initDataUnsafe?.user?.first_name || '–ò–≥—Ä–æ–∫'
  };

  // –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
  const gameState = {
    colors: ['#FF5252','#4CAF50','#2196F3','#FFC107','#9C27B0','#00BCD4'],
    slotWidth: 0,
    serverTimeOffset: 0,
    isPlacingBet: false,
    timerInterval: null
  };

  // –≠–ª–µ–º–µ–Ω—Ç—ã –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
  const elements = {
    rouletteSlots: document.getElementById('roulette-slots'),
    rouletteSlotsWrapper: document.getElementById('roulette-slots-wrapper'),
    winnerDisplay: document.getElementById('winner-display'),
    placeBetBtn: document.getElementById('place-bet-btn'),
    timerDisplay: document.getElementById('timer-display'),
    timeLeftSpan: document.getElementById('time-left')
  };

  // –°—Å—ã–ª–∫–∏ Firebase
  const roomRef = db.ref('pvpRoulette/room');
  const serverTimeRef = db.ref('.info/serverTimeOffset');

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
  function initRouletteGame() {
    // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏
    serverTimeRef.on('value', (snap) => {
      gameState.serverTimeOffset = snap.val() || 0;
    });

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–Ω–∞—Ç—ã
    roomRef.once('value').then(snapshot => {
      if (!snapshot.exists()) resetRoom();
    }).catch(console.error);

    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ —Å—Ç–∞–≤–∫–∏
    elements.placeBetBtn.addEventListener('click', placeBetHandler);

    // –°–ª—É—à–∞—Ç–µ–ª—å –∫–æ–º–Ω–∞—Ç—ã
    roomRef.on('value', roomListener);
  }

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–Ω–∞—Ç—ã
  function roomListener(snapshot) {
    const room = snapshot.val();
    if (!room) return resetRoom();

    // –í–∞–ª–∏–¥–∞—Ü–∏—è –∏–≥—Ä–æ–∫–æ–≤
    const validPlayers = {};
    if (room.players) {
      Object.entries(room.players).forEach(([id, player]) => {
        if (player?.color && player?.name && player?.betTime) {
          validPlayers[id] = player;
        }
      });
    }

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –µ—Å–ª–∏ –µ—Å—Ç—å –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–µ –∏–≥—Ä–æ–∫–∏
    if (Object.keys(validPlayers).length !== Object.keys(room.players||{}).length) {
      return roomRef.child('players').set(validPlayers);
    }

    updateUI(room);
  }

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å—Ç–∞–≤–∫–∏
  async function placeBetHandler() {
    if (gameState.isPlacingBet) return;
    gameState.isPlacingBet = true;

    try {
      const room = (await roomRef.once('value')).val();
      if (!room) return;

      if (room.status !== 'waiting' && room.status !== 'betting') {
        alert('–°—Ç–∞–≤–∫–∏ –∑–∞–∫—Ä—ã—Ç—ã');
        return;
      }

      if (room.players?.[currentPlayer.id]) {
        alert('–í—ã —É–∂–µ —Å–¥–µ–ª–∞–ª–∏ —Å—Ç–∞–≤–∫—É');
        return;
      }

      const usedColors = Object.values(room.players||{}).map(p=>p.color).filter(Boolean);
      const availableColor = gameState.colors.find(c=>!usedColors.includes(c))||gameState.colors[0];

      await roomRef.child('players').child(currentPlayer.id).set({
        name: currentPlayer.name,
        color: availableColor,
        betTime: getServerTime()
      });

      const playerCount = Object.keys(room.players||{}).length + 1;
      if (playerCount >= 2 && room.status === 'waiting') {
        await roomRef.update({
          status: 'betting',
          startTime: getServerTime()
        });
      }
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ —Å—Ç–∞–≤–∫–∏:',error);
      alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å—Ç–∞–≤–∫–µ');
    } finally {
      gameState.isPlacingBet = false;
    }
  }

  // –°–±—Ä–æ—Å –∫–æ–º–Ω–∞—Ç—ã
  function resetRoom() {
    clearTimer();
    const roomData = {
      status: 'waiting',
      players: {},
      startTime: null,
      winner: null,
      lastReset: getServerTime()
    };
    return roomRef.set(roomData).catch(console.error);
  }

  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
  function updateUI(room) {
    clearTimer();

    switch(room.status) {
      case 'waiting':
        elements.placeBetBtn.disabled = false;
        elements.placeBetBtn.textContent = '–°–¥–µ–ª–∞—Ç—å —Å—Ç–∞–≤–∫—É';
        elements.timerDisplay.style.display = 'none';
        elements.winnerDisplay.textContent = '';
        break;
        
      case 'betting':
        elements.placeBetBtn.disabled = !!room.players?.[currentPlayer.id];
        elements.placeBetBtn.textContent = room.players?.[currentPlayer.id] 
          ? '–í—ã —É–∂–µ —Å–¥–µ–ª–∞–ª–∏ —Å—Ç–∞–≤–∫—É' 
          : '–°–¥–µ–ª–∞—Ç—å —Å—Ç–∞–≤–∫—É';
        
        if (room.startTime) startTimer(room.startTime);
        break;
        
      case 'spinning':
        elements.placeBetBtn.disabled = true;
        elements.timerDisplay.style.display = 'none';
        break;
        
      case 'finished':
        showWinner(room.winner);
        elements.placeBetBtn.disabled = true;
        elements.timerDisplay.style.display = 'none';
        break;
    }
    
    updateRouletteDisplay(room.players||{});
  }

  // –¢–∞–π–º–µ—Ä
  function startTimer(startTime) {
    clearTimer();
    elements.timerDisplay.style.display = 'block';
    
    function updateTimer() {
      const elapsed = Math.floor((getServerTime()-startTime)/1000);
      const timeLeft = Math.max(0,30-elapsed);
      elements.timeLeftSpan.textContent = timeLeft;
      
      if (timeLeft <= 0) {
        clearTimer();
        checkStartRoulette();
      }
    }
    
    updateTimer();
    gameState.timerInterval = setInterval(updateTimer,1000);
  }

  function clearTimer() {
    if (gameState.timerInterval) {
      clearInterval(gameState.timerInterval);
      gameState.timerInterval = null;
    }
  }

  function checkStartRoulette() {
    roomRef.once('value').then(snap=>{
      const room = snap.val();
      if (room?.status === 'betting' && Object.keys(room.players||{}).length >= 2) {
        startRoulette(room);
      }
    });
  }

  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä—É–ª–µ—Ç–∫–∏
  function updateRouletteDisplay(players) {
    elements.rouletteSlots.innerHTML = '';
    const activePlayers = Object.values(players).filter(p=>p?.color);
    const totalPlayers = activePlayers.length;
    
    if (totalPlayers === 0) return;
    
    gameState.slotWidth = 100/totalPlayers;
    
    activePlayers.forEach((player,index)=>{
      createSlot(player,index,totalPlayers);
    });
  }

  // –°–æ–∑–¥–∞–Ω–∏–µ —Å–ª–æ—Ç–∞
  function createSlot(player,index,totalPlayers) {
    const slot = document.createElement('div');
    slot.className = 'roulette-slot';
    slot.style.backgroundColor = player.color;
    slot.style.width = `${gameState.slotWidth}%`;
    slot.style.left = `${index*gameState.slotWidth}%`;
    
    const percent = document.createElement('div');
    percent.className = 'slot-percent';
    percent.textContent = `${Math.round(100/totalPlayers)}%`;
    percent.style.color = getContrastColor(player.color);
    
    slot.appendChild(percent);
    elements.rouletteSlots.appendChild(slot);
  }

  // –ó–∞–ø—É—Å–∫ —Ä—É–ª–µ—Ç–∫–∏
  function startRoulette(room) {
    const activePlayers = Object.entries(room.players||{}).filter(([_,p])=>p?.color);
    if (activePlayers.length < 2) return resetRoom();

    roomRef.update({status:'spinning'}).then(()=>{
      const spinDuration = 3000 + Math.random()*4000;
      const winnerIndex = Math.floor(Math.random()*activePlayers.length);
      const winnerId = activePlayers[winnerIndex][0];
      const winner = activePlayers[winnerIndex][1];
      
      gameState.slotWidth = 100/activePlayers.length;
      animateRoulette(winnerIndex,spinDuration,()=>{
        roomRef.update({
          status: 'finished',
          winner: {id:winnerId,name:winner.name,color:winner.color},
          finishTime: getServerTime()
        }).then(()=>{
          setTimeout(resetRoom,10000);
        });
      });
    });
  }

  // –ê–Ω–∏–º–∞—Ü–∏—è —Ä—É–ª–µ—Ç–∫–∏
  function animateRoulette(winnerIndex,duration,callback) {
    const targetPosition = 100-(winnerIndex*gameState.slotWidth);
    
    elements.rouletteSlotsWrapper.style.transition = 'none';
    elements.rouletteSlotsWrapper.style.transform = 'translateX(0)';
    
    setTimeout(()=>{
      elements.rouletteSlotsWrapper.style.transition = `transform ${duration/1000}s cubic-bezier(0.2,0.1,0.2,1)`;
      elements.rouletteSlotsWrapper.style.transform = `translateX(-${targetPosition}%)`;
      
      setTimeout(callback,duration);
    },10);
  }

  // –ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–±–µ–¥–∏—Ç–µ–ª—è
  function showWinner(winner) {
    if (!winner) return;
    elements.winnerDisplay.innerHTML = `
      <div class="winner-box" style="background-color:${winner.color||'#7f5af0'}">
        –ü–æ–±–µ–¥–∏—Ç–µ–ª—å: ${winner.name||'–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∏–≥—Ä–æ–∫'}!
      </div>
    `;
  }

  // –ö–æ–Ω—Ç—Ä–∞—Å—Ç–Ω—ã–π —Ü–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞
  function getContrastColor(hexColor) {
    if (!hexColor||typeof hexColor!=='string'||hexColor.length<7) return '#FFFFFF';
    const r=parseInt(hexColor.substring(1,3),16);
    const g=parseInt(hexColor.substring(3,5),16);
    const b=parseInt(hexColor.substring(5,7),16);
    const brightness=(r*299+g*587+b*114)/1000;
    return brightness>128?'#000000':'#FFFFFF';
  }

  // –°–µ—Ä–≤–µ—Ä–Ω–æ–µ –≤—Ä–µ–º—è
  function getServerTime() {
    return Date.now()+gameState.serverTimeOffset;
  }

  // –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã
  initRouletteGame();
});
</script>
</body>
</html>