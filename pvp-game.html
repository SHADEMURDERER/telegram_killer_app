<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Gizmo PVP</title>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <link rel="stylesheet" href="styles/main.css">
  <link rel="stylesheet" href="styles/pvp-game.css">
</head>
<body>
<!-- Весь HTML остаётся таким же как в предыдущей версии -->
<script>
// Инициализация Firebase и состояние игры
const firebaseConfig = {
  apiKey: "AIzaSyC6EklCDD25kU_nuXyeh5mj9F24KECyYpM",
  databaseURL: "https://gizmo-27843-default-rtdb.firebaseio.com",
  projectId: "gizmo-27843"
};

const app = firebase.initializeApp(firebaseConfig);
const db = firebase.database();

// Текущий игрок
const currentPlayer = {
  id: window.Telegram?.WebApp?.initDataUnsafe?.user?.id || 'player_' + Math.random().toString(36).slice(2, 9),
  name: window.Telegram?.WebApp?.initDataUnsafe?.user?.first_name || 'Игрок'
};

// Состояние игры
const gameState = {
  colors: ['#FF5252', '#4CAF50', '#2196F3', '#FFC107', '#9C27B0', '#00BCD4'],
  slotWidth: 0,
  serverTimeOffset: 0,
  isPlacingBet: false,
  timerInterval: null // Для хранения интервала таймера
};

// Элементы интерфейса
const rouletteSlots = document.getElementById('roulette-slots');
const rouletteSlotsWrapper = document.getElementById('roulette-slots-wrapper');
const winnerDisplay = document.getElementById('winner-display');
const placeBetBtn = document.getElementById('place-bet-btn');
const timerDisplay = document.getElementById('timer-display');
const timeLeftSpan = document.getElementById('time-left');

// Ссылки Firebase
const roomRef = db.ref('pvpRoulette_v4/room'); // Новая версия
const serverTimeRef = db.ref('.info/serverTimeOffset');

// Инициализация игры
function initRouletteGame() {
  serverTimeRef.on('value', (snap) => {
    gameState.serverTimeOffset = snap.val() || 0;
  });

  roomRef.once('value').then(snapshot => {
    if (!snapshot.exists()) resetRoom();
  });

  placeBetBtn.addEventListener('click', placeBetHandler);
  roomRef.on('value', roomListener);
}

// Обработчик комнаты
function roomListener(snapshot) {
  const room = snapshot.val();
  if (!room) return resetRoom();

  // Валидация игроков
  const validPlayers = {};
  if (room.players) {
    Object.entries(room.players).forEach(([id, player]) => {
      if (player?.color && player?.name && player?.betTime) {
        validPlayers[id] = player;
      }
    });
  }

  // Обновление если есть невалидные игроки
  if (Object.keys(validPlayers).length !== Object.keys(room.players || {}).length) {
    return roomRef.child('players').set(validPlayers);
  }

  updateUI(room);
}

// Обработчик ставки
async function placeBetHandler() {
  if (gameState.isPlacingBet) return;
  gameState.isPlacingBet = true;

  try {
    const room = (await roomRef.once('value')).val();
    if (!room) return;

    if (room.status !== 'waiting' && room.status !== 'betting') {
      alert('Ставки временно закрыты');
      return;
    }

    if (room.players?.[currentPlayer.id]) {
      alert('Вы уже сделали ставку');
      return;
    }

    const usedColors = Object.values(room.players || {}).map(p => p.color).filter(Boolean);
    const availableColor = gameState.colors.find(c => !usedColors.includes(c)) || gameState.colors[0];

    await roomRef.child('players').child(currentPlayer.id).set({
      name: currentPlayer.name,
      color: availableColor,
      betTime: getServerTime()
    });

    const playerCount = Object.keys(room.players || {}).length + 1;
    if (playerCount >= 2 && room.status === 'waiting') {
      await roomRef.update({
        status: 'betting',
        startTime: getServerTime()
      });
    }
  } catch (error) {
    console.error('Ошибка ставки:', error);
    alert('Ошибка при размещении ставки');
  } finally {
    gameState.isPlacingBet = false;
  }
}

// Сброс комнаты
function resetRoom() {
  clearTimer(); // Очищаем таймер при сбросе
  const roomData = {
    status: 'waiting',
    players: {},
    startTime: null,
    winner: null,
    lastReset: getServerTime()
  };

  return roomRef.set(roomData).catch(console.error);
}

// Обновление интерфейса
function updateUI(room) {
  // Очищаем предыдущий таймер
  clearTimer();

  switch (room.status) {
    case 'waiting':
      placeBetBtn.disabled = false;
      placeBetBtn.textContent = 'Сделать ставку';
      timerDisplay.style.display = 'none';
      winnerDisplay.textContent = '';
      break;
      
    case 'betting':
      placeBetBtn.disabled = !!room.players?.[currentPlayer.id];
      placeBetBtn.textContent = room.players?.[currentPlayer.id] 
        ? 'Вы уже сделали ставку' 
        : 'Сделать ставку';
      
      // Запускаем таймер
      if (room.startTime) {
        startTimer(room.startTime);
      }
      break;
      
    case 'spinning':
      placeBetBtn.disabled = true;
      timerDisplay.style.display = 'none';
      break;
      
    case 'finished':
      showWinner(room.winner);
      placeBetBtn.disabled = true;
      timerDisplay.style.display = 'none';
      break;
  }
  
  updateRouletteDisplay(room.players || {});
}

// Запуск таймера
function startTimer(startTime) {
  clearTimer(); // Очищаем предыдущий таймер
  
  timerDisplay.style.display = 'block';
  
  function updateTimer() {
    const elapsed = Math.floor((getServerTime() - startTime) / 1000);
    const timeLeft = Math.max(0, 30 - elapsed);
    timeLeftSpan.textContent = timeLeft;
    
    if (timeLeft <= 0) {
      clearTimer();
      checkStartRoulette();
    }
  }
  
  // Обновляем сразу и каждую секунду
  updateTimer();
  gameState.timerInterval = setInterval(updateTimer, 1000);
}

// Очистка таймера
function clearTimer() {
  if (gameState.timerInterval) {
    clearInterval(gameState.timerInterval);
    gameState.timerInterval = null;
  }
}

// Проверка старта рулетки
function checkStartRoulette() {
  roomRef.once('value').then(snapshot => {
    const room = snapshot.val();
    if (room?.status === 'betting' && Object.keys(room.players || {}).length >= 2) {
      startRoulette(room);
    }
  });
}

// Обновление рулетки
function updateRouletteDisplay(players) {
  rouletteSlots.innerHTML = '';
  const activePlayers = Object.values(players).filter(p => p?.color);
  const totalPlayers = activePlayers.length;
  
  if (totalPlayers === 0) return;
  
  gameState.slotWidth = 100 / totalPlayers;
  
  activePlayers.forEach((player, index) => {
    createSlot(player, index, totalPlayers);
  });
}

// Создание слота
function createSlot(player, index, totalPlayers) {
  const slot = document.createElement('div');
  slot.className = 'roulette-slot';
  slot.style.backgroundColor = player.color;
  slot.style.width = `${gameState.slotWidth}%`;
  slot.style.left = `${index * gameState.slotWidth}%`;
  
  const percent = document.createElement('div');
  percent.className = 'slot-percent';
  percent.textContent = `${Math.round(100 / totalPlayers)}%`;
  percent.style.color = getContrastColor(player.color);
  
  slot.appendChild(percent);
  rouletteSlots.appendChild(slot);
}

// Запуск рулетки
function startRoulette(room) {
  const activePlayers = Object.entries(room.players || {}).filter(([_, p]) => p?.color);
  if (activePlayers.length < 2) return resetRoom();

  roomRef.update({ status: 'spinning' }).then(() => {
    const spinDuration = 3000 + Math.random() * 4000;
    const winnerIndex = Math.floor(Math.random() * activePlayers.length);
    const winnerId = activePlayers[winnerIndex][0];
    const winner = activePlayers[winnerIndex][1];
    
    gameState.slotWidth = 100 / activePlayers.length;
    animateRoulette(winnerIndex, spinDuration, () => {
      roomRef.update({
        status: 'finished',
        winner: {
          id: winnerId,
          name: winner.name,
          color: winner.color
        },
        finishTime: getServerTime()
      }).then(() => {
        setTimeout(resetRoom, 10000);
      });
    });
  });
}

// Анимация рулетки
function animateRoulette(winnerIndex, duration, callback) {
  const targetPosition = 100 - (winnerIndex * gameState.slotWidth);
  
  rouletteSlotsWrapper.style.transition = 'none';
  rouletteSlotsWrapper.style.transform = 'translateX(0)';
  
  setTimeout(() => {
    rouletteSlotsWrapper.style.transition = `transform ${duration/1000}s cubic-bezier(0.2, 0.1, 0.2, 1)`;
    rouletteSlotsWrapper.style.transform = `translateX(-${targetPosition}%)`;
    
    setTimeout(callback, duration);
  }, 10);
}

// Показать победителя
function showWinner(winner) {
  if (!winner) return;
  
  winnerDisplay.innerHTML = `
    <div class="winner-box" style="background-color: ${winner.color || '#7f5af0'}">
      Победитель: ${winner.name || 'Неизвестный игрок'}!
    </div>
  `;
}

// Контрастный цвет текста
function getContrastColor(hexColor) {
  if (!hexColor || typeof hexColor !== 'string' || hexColor.length < 7) return '#FFFFFF';
  
  const r = parseInt(hexColor.substring(1, 3), 16);
  const g = parseInt(hexColor.substring(3, 5), 16);
  const b = parseInt(hexColor.substring(5, 7), 16);
  const brightness = (r * 299 + g * 587 + b * 114) / 1000;
  return brightness > 128 ? '#000000' : '#FFFFFF';
}

// Серверное время
function getServerTime() {
  return Date.now() + gameState.serverTimeOffset;
}

// Инициализация
document.addEventListener('DOMContentLoaded', initRouletteGame);
</script>
</body>
</html>